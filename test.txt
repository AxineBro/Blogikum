============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-7.1.3, pluggy-1.0.0 -- /home/axine/Dev/django_sprint4/venv/bin/python3
django: settings: blogicum.settings (from ini)
rootdir: /home/axine/Dev/django_sprint4, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 25 items

tests/test_content.py::TestContent::test_unpublished FAILED              [  4%]
tests/test_content.py::TestContent::test_only_own_pubs_in_category FAILED [  8%]
tests/test_content.py::TestContent::test_only_own_pubs_in_profile FAILED [ 12%]
tests/test_content.py::TestContent::test_unpublished_category FAILED     [ 16%]
tests/test_content.py::TestContent::test_future_posts FAILED             [ 20%]
tests/test_content.py::TestContent::test_pagination FAILED               [ 24%]
tests/test_content.py::TestContent::test_image_visible FAILED            [ 28%]
tests/test_err_pages.py::test_custom_err_handlers FAILED                 [ 32%]
tests/test_users.py::test_custom_err_handlers FAILED                     [ 36%]
tests/test_users.py::test_profile FAILED                                 [ 40%]
tests/test_comment.py::test_comment_created_at ERROR                     [ 44%]
tests/test_comment.py::test_comment ERROR                                [ 48%]
tests/test_comment.py::test_404_on_comment_deleted_post ERROR            [ 52%]
tests/test_post.py::test_post_created_at PASSED                          [ 56%]
tests/test_post.py::test_post ERROR                                      [ 60%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field] <- tests/conftest.py ERROR [ 64%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field] <- tests/conftest.py ERROR [ 68%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field] <- tests/conftest.py ERROR [ 72%]
tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field] <- tests/conftest.py ERROR [ 76%]
tests/test_emails.py::test_gitignore PASSED                              [ 80%]
tests/test_emails.py::test_email_backend_settings FAILED                 [ 84%]
tests/test_err_pages.py::test_csrf_failure_view FAILED                   [ 88%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`image` field] <- tests/conftest.py FAILED [ 92%]
tests/test_post.py::TestPostModelAttrs::test_model_attrs[`pub_date` field] <- tests/conftest.py PASSED [ 96%]
tests/test_static_pages.py::test_static_pages_as_cbv FAILED              [100%]
tests/test_static_pages.py::test_static_pages_as_cbv ERROR               [100%]

==================================== ERRORS ====================================
__________________ ERROR at setup of test_comment_created_at ___________________

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
________________________ ERROR at setup of test_comment ________________________

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450d5dd90>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450d5dd90>
request = <WSGIRequest: GET '/posts/1/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, path = '/posts/1/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f680>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f680>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450d5e1e0>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad6080>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f800>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f800>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2b230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450d5d790>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad7ac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f980>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5f980>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2ac30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450d5ee70>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad5300>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fb00>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fb00>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2ae30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450d5f290>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad7100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fb30>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fb30>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2b430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450d5cda0>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad5800>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fda0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5fda0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2b030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450d5eae0>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450804580>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d728a0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d728a0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450d5e690>
request = <WSGIRequest: GET '/posts/1/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/1/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ad7040>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d72690>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d72690>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2b630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x79b450d5df40>
post_with_published_location = <Post: Say Whose Us Administration Your College>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.12/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.12/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.12/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.12/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
venv/lib/python3.12/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.12/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: in urlconf_module
    return import_module(self.urlconf_name)
/usr/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
blogicum/blogicum/urls.py:39: in <module>
    path('profile/', include('users.urls')),
venv/lib/python3.12/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'users.urls'

/usr/lib/python3.12/importlib/__init__.py:90: ModuleNotFoundError
______________ ERROR at setup of test_404_on_comment_deleted_post ______________

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450d71880>
request = <WSGIRequest: GET '/posts/2/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450d71880>
request = <WSGIRequest: GET '/posts/2/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, path = '/posts/2/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450afe450>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450afe450>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2ba30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450afcd70>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506bddc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4512625a0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4512625a0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2bc30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450afd8e0>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c6900>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122ff20>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122ff20>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450afdcd0>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c68c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5d8e0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5d8e0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450afda30>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c4080>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5cd10>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5cd10>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450afd550>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c5d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450d5d640>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450d5d640>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450afde20>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c4e80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ab55b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ab55b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450afdeb0>
request = <WSGIRequest: GET '/posts/2/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/posts/2/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4506c5100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ab68d0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ab68d0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450b84a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x79b450d70680>
post_with_published_location = <Post: Room Defense Minute Speech Create Firm>

    @pytest.fixture
    def post_comment_context_form_item(
        user_client: Client, post_with_published_location
    ) -> Tuple[str, BaseForm]:
>       response = get_a_post_get_response_safely(
            user_client, post_with_published_location.id
        )

tests/fixtures/posts.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:263: in get_a_post_get_response_safely
    return get_get_response_safely(
tests/conftest.py:254: in get_get_response_safely
    response = user_client.get(url)
venv/lib/python3.12/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.12/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.12/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.12/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
venv/lib/python3.12/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.12/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: in urlconf_module
    return import_module(self.urlconf_name)
/usr/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
blogicum/blogicum/urls.py:39: in <module>
    path('profile/', include('users.urls')),
venv/lib/python3.12/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'users.urls'

/usr/lib/python3.12/importlib/__init__.py:90: ModuleNotFoundError
_________________________ ERROR at setup of test_post __________________________

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
____ ERROR at setup of TestCommentModelAttrs.test_model_attrs[`post` field] ____

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
___ ERROR at setup of TestCommentModelAttrs.test_model_attrs[`author` field] ___

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
____ ERROR at setup of TestCommentModelAttrs.test_model_attrs[`text` field] ____

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
_ ERROR at setup of TestCommentModelAttrs.test_model_attrs[`created_at` field] _

    @pytest.fixture
    def CommentModel() -> Model:
        try:
            from blog import models
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `blog/models.py` нет ошибок. "
                "При импорте `models.py` возникла ошибка:\n"
                f"{type(e).__name__}: {e}"
            )
        models_src_code = getsource(models)
        models_src_clean = re.sub("#.+", "", models_src_code)
        class_defs = re.findall(
            r"(class +\w+[\w\W]+?)(?=class)", models_src_clean + "class"
        )
        comment_class_name = ""
        known_class_names = {"BaseModel", "Meta", "Category", "Location", "Post"}
        for class_def in class_defs:
            class_names = re.findall(
                r"class +(\w+)[\w\W]+ForeignKey[\w\W]+Post", class_def
            )
            for name in class_names:
                if name not in known_class_names:
                    comment_class_name = name
                    break
            if comment_class_name:
                break
>       assert comment_class_name, (
            "Убедитесь, что в файле `blog/models.py` объявлена модель комментария"
            " с полем `ForeignKey`, связывающим её с моделью `Post`."
        )
E       AssertionError: Убедитесь, что в файле `blog/models.py` объявлена модель комментария с полем `ForeignKey`, связывающим её с моделью `Post`.
E       assert ''

tests/conftest.py:239: AssertionError
________________ ERROR at teardown of test_static_pages_as_cbv _________________

request = <SubRequest 'cleanup' for <Function test_unpublished>>

    @pytest.fixture(scope="session", autouse=True)
    def cleanup(request):
        start_time = time.time()
    
        yield
    
        from blogicum import settings
    
>       image_dir = Path(settings.__file__).parent.parent / settings.MEDIA_ROOT
E       AttributeError: module 'blogicum.settings' has no attribute 'MEDIA_ROOT'

tests/conftest.py:358: AttributeError
=================================== FAILURES ===================================
_________________________ TestContent.test_unpublished _________________________

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b4510ea870>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b4510ea870>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/pennychristensen/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b451279190>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b451279190>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451119430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b451263d40>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b451242e40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45127af00>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45127af00>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451119a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b451262d50>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4510f4240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45127ba10>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45127ba10>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451119c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b451263fb0>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45127c7c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8620>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8620>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451119e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b451263bf0>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45127e340>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8110>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8110>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b45111a030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b4512633b0>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45109b040>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b86b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b86b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b45111a230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b451263a70>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45127f700>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8650>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8650>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b45111a430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b45127a870>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4510a4840>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b9010>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b9010>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b45111a630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b4511d97f0>
client = <django.test.client.Client object at 0x79b4510e9a00>
url = '/profile/pennychristensen/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b4510e9a00>
path = '/profile/pennychristensen/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b4510e9a00>
path = '/profile/pennychristensen/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b4510e9a00>, method = 'GET'
path = '/profile/pennychristensen/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/pennychristensen/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/pennychristensen/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b4510e9a00>
request = {'PATH_INFO': '/profile/pennychristensen/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=h60dwqf1u75g1452gouhu6zenkb8pmgu', 'PATH_INFO': '/profile/pennychristensen/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815362219904'
exception_uid = 'request-exception-133815362219904'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b4510ea870>
environ = {'HTTP_COOKIE': 'sessionid=h60dwqf1u75g1452gouhu6zenkb8pmgu', 'PATH_INFO': '/profile/pennychristensen/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b4510ea870>
request = <WSGIRequest: GET '/profile/pennychristensen/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/pennychristensen/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4510a5680>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8f80>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4510b8f80>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b45111a830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b451309c10>
unpublished_posts_with_published_locations = [<Post: Remain Behind Learn Sing Increase Wonder>, <Post: Dream Get Any Produce Exactly Try>, <Post: View Power World Claim Institution Couple>]

    def test_unpublished(self, unpublished_posts_with_published_locations):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b4511d97f0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
__________________ TestContent.test_only_own_pubs_in_category __________________

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b45100c050>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b45100c050>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/category/both-country-record/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be86b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be86b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451035e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b4510239b0>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450bc76c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8920>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8920>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b451023f50>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450bc4d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a70>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a70>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b4510b8fe0>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450bc51c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8b60>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8b60>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b451023bc0>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450bc4500>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8b90>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8b90>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b451023b30>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450bc4440>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a10>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a10>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b451023ef0>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d57740>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a40>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8a40>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b451021250>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d57e80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8bf0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8bf0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451036e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.CategoryPostContentTester object at 0x79b450eadeb0>
client = <django.test.client.Client object at 0x79b45100c170>
url = '/category/both-country-record/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b45100c170>
path = '/category/both-country-record/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b45100c170>
path = '/category/both-country-record/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b45100c170>, method = 'GET'
path = '/category/both-country-record/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/both-country-record/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/both-country-record/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b45100c170>
request = {'PATH_INFO': '/category/both-country-record/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=ltbyh8s00sv80a7625x7i6kzra9yrd2t', 'PATH_INFO': '/category/both-country-record/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815355577984'
exception_uid = 'request-exception-133815355577984'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b45100c050>
environ = {'HTTP_COOKIE': 'sessionid=ltbyh8s00sv80a7625x7i6kzra9yrd2t', 'PATH_INFO': '/category/both-country-record/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b45100c050>
request = <WSGIRequest: GET '/category/both-country-record/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/category/both-country-record/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d54cc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450be8c80>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450be8c80>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b45130a240>
user_client = <django.test.client.Client object at 0x79b45100c170>
post_with_published_location = <Post: Sometimes Benefit Citizen Approach Discover If>
post_with_another_category = <Post: List Feel Type Already Science Color>

    def test_only_own_pubs_in_category(
        self, user_client, post_with_published_location,
            post_with_another_category
    ):
>       response = self.category_tester.user_client_testget()

tests/test_content.py:380: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.CategoryPostContentTester object at 0x79b450eadeb0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница категории загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница категории загружается без ошибок.

tests/test_content.py:266: AssertionError
__________________ TestContent.test_only_own_pubs_in_profile ___________________

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450b9c8c0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450b9c8c0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/kaitlinwolfe/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450c90110>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450c90110>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450e3f2f0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b12580>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450c90380>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450c90380>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450e3eed0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b12380>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450c904d0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450c904d0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450e3f2c0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b11900>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450c905c0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450c905c0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450e3f620>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b11600>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450c905f0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450c905f0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450e3f680>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b1cf00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b451279130>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b451279130>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450e3f6e0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450b1d980>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45100c200>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45100c200>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450e3f800>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4511b1600>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4512927b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4512927b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b450e3c9e0>
client = <django.test.client.Client object at 0x79b450b9c8f0>
url = '/profile/kaitlinwolfe/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450b9c8f0>
path = '/profile/kaitlinwolfe/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450b9c8f0>
path = '/profile/kaitlinwolfe/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450b9c8f0>, method = 'GET'
path = '/profile/kaitlinwolfe/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/kaitlinwolfe/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/kaitlinwolfe/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450b9c8f0>
request = {'PATH_INFO': '/profile/kaitlinwolfe/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=9jnzmdlmxhlzguulp0apmjef3umyvzh3', 'PATH_INFO': '/profile/kaitlinwolfe/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815354865728'
exception_uid = 'request-exception-133815354865728'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450b9c8c0>
environ = {'HTTP_COOKIE': 'sessionid=9jnzmdlmxhlzguulp0apmjef3umyvzh3', 'PATH_INFO': '/profile/kaitlinwolfe/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450b9c8c0>
request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kaitlinwolfe/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45119bd40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4512934d0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4512934d0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b45130a8d0>
user_client = <django.test.client.Client object at 0x79b450b9c8f0>
post_with_published_location = <Post: Body Music Guess Answer True Buy>
post_of_another_author = <Post: While Church Article Political Family Serve>

    def test_only_own_pubs_in_profile(
            self, user_client, post_with_published_location,
            post_of_another_author
    ):
>       response = self.profile_tester.user_client_testget()

tests/test_content.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b450e3c9e0>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
____________________ TestContent.test_unpublished_category _____________________

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450e3e7b0>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450e3e7b0>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/felicia48/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122da90>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122da90>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b451200f20>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea3240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122e270>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122e270>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b451203920>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea1dc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122f470>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122f470>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c64c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b451203b60>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea2080>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122e240>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122e240>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b451203650>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea2240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122f740>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122f740>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b4512017f0>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea0780>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b45122d340>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b45122d340>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b4512000b0>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea0e00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4511d83b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4511d83b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b451200830>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ea1300>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4511d8da0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4511d8da0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b450e3ee40>
client = <django.test.client.Client object at 0x79b450e3edb0>
url = '/profile/felicia48/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450e3edb0>
path = '/profile/felicia48/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450e3edb0>
path = '/profile/felicia48/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450e3edb0>, method = 'GET'
path = '/profile/felicia48/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/felicia48/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/felicia48/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450e3edb0>
request = {'PATH_INFO': '/profile/felicia48/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=mf10qvk71wqra4iarckuyjhf9mtqyym5', 'PATH_INFO': '/profile/felicia48/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815362456000'
exception_uid = 'request-exception-133815362456000'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450e3e7b0>
environ = {'HTTP_COOKIE': 'sessionid=mf10qvk71wqra4iarckuyjhf9mtqyym5', 'PATH_INFO': '/profile/felicia48/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450e3e7b0>
request = <WSGIRequest: GET '/profile/felicia48/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/felicia48/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450ec5100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b4511d9640>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b4511d9640>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b45130af30>
user_client = <django.test.client.Client object at 0x79b450e3edb0>
posts_with_unpublished_category = [<Post: Modern Dog Yard Find Instead Note>, <Post: Standard Agree Sure Community Student Assume>, <Post: Bank Probably Debate Next Seek Decide>]

    def test_unpublished_category(
        self, user_client, posts_with_unpublished_category
    ):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b450e3ee40>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_future_posts _________________________

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b451203440>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b451203440>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, path = '/profile/gdavis/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3110>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3110>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b451037430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450ee1eb0>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509c0d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3440>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3440>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450ee1e50>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509beac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3560>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3560>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450ee1df0>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bfec0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee36b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee36b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c65e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450ee22d0>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bd4c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee36e0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee36e0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450ee25d0>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bd880>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3800>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3800>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b45122d190>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bce00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3a10>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3a10>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450ee2180>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bc340>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3c80>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3c80>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b450ee3140>
client = <django.test.client.Client object at 0x79b451201fa0>
url = '/profile/gdavis/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b451201fa0>
path = '/profile/gdavis/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b451201fa0>
path = '/profile/gdavis/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b451201fa0>, method = 'GET'
path = '/profile/gdavis/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/gdavis/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/gdavis/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b451201fa0>
request = {'PATH_INFO': '/profile/gdavis/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=lbbalxnz7msszrt5z6kfgp7o4lhzbsyi', 'PATH_INFO': '/profile/gdavis/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815359035968'
exception_uid = 'request-exception-133815359035968'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b451203440>
environ = {'HTTP_COOKIE': 'sessionid=lbbalxnz7msszrt5z6kfgp7o4lhzbsyi', 'PATH_INFO': '/profile/gdavis/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b451203440>
request = <WSGIRequest: GET '/profile/gdavis/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/gdavis/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4509bc5c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3f20>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ee3f20>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b45130b500>
user_client = <django.test.client.Client object at 0x79b451201fa0>
future_posts = [<Post: Resource Ball Teacher International Share Reveal>, <Post: Decade Manager Such Agency Bill Capital>, <Post: Beautiful Hear Respond Its Program Economy>]

    def test_future_posts(self, user_client, future_posts):
>       profile_response = self.profile_tester.user_client_testget()

tests/test_content.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b450ee3140>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
_________________________ TestContent.test_pagination __________________________

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450ee2c30>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450ee2c30>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/cynthia31/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8ce0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8ce0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450f1a000>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450de2dc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8f20>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8f20>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450f1bdd0>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9c340>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450efbe60>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450efbe60>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c66e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450f1afc0>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9c3c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9160>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9160>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450f1b110>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9db80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9280>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9280>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450ef8140>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9d500>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8fb0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef8fb0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450ef8320>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9e400>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9220>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9220>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450c67c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450ef8350>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9ee00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef95e0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef95e0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b450f19c40>
client = <django.test.client.Client object at 0x79b450ee0590>
url = '/profile/cynthia31/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450ee0590>
path = '/profile/cynthia31/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450ee0590>
path = '/profile/cynthia31/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450ee0590>, method = 'GET'
path = '/profile/cynthia31/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/cynthia31/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/cynthia31/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450ee0590>
request = {'PATH_INFO': '/profile/cynthia31/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=wmcz0640e13od4fskbhkd4w7je4dsqim', 'PATH_INFO': '/profile/cynthia31/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815357809216'
exception_uid = 'request-exception-133815357809216'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450ee2c30>
environ = {'HTTP_COOKIE': 'sessionid=wmcz0640e13od4fskbhkd4w7je4dsqim', 'PATH_INFO': '/profile/cynthia31/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450ee2c30>
request = <WSGIRequest: GET '/profile/cynthia31/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/cynthia31/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d9e100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9850>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450ef9850>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b45130bad0>
user_client = <django.test.client.Client object at 0x79b450ee0590>
many_posts_with_published_locations = [<Post: Find Easy Note Never Defense Over>, <Post: Step Game Until Under Relationship Early>, <Post: State Piece Movie...ly Benefit Seem>, <Post: Bag Born Discussion Pull Bank Because>, <Post: Mean Light Natural According Man Serious>, ...]

    def test_pagination(
        self, user_client, many_posts_with_published_locations
    ):
        posts = many_posts_with_published_locations
    
        assert len(posts) > self.profile_tester.n_per_page
        assert len(posts) > self.main_tester.n_per_page
        assert len(posts) > self.category_tester.n_per_page
    
        for (
            tester,
            response_get_func,
            ordering_err_msg,
            pagination_err_msg,
        ) in (
            (
                self.profile_tester,
                self.profile_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора работает"
                    " пагинация."
                ),
            ),
            (
                self.profile_tester,
                self.profile_tester.another_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " профиля автора отсортированными по времени их"
                    " публикации, «от новых к старым»."
                ),
                (
                    "Убедитесь, что на странице профиля автора "
                    "пагинация работает в соответствии с заданием ."
                ),
            ),
            (
                self.main_tester,
                self.main_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст главной"
                    " страницы отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на главной странице "
                "пагинация работает в соответствии с заданием .",
            ),
            (
                self.category_tester,
                self.category_tester.user_client_testget,
                (
                    "Убедитесь, что публикации передаются в контекст страницы"
                    " категории отсортированными по времени их публикации, «от"
                    " новых к старым»."
                ),
                "Убедитесь, что на странице категории "
                "пагинация работает в соответствии с заданием .",
            ),
        ):
>           response = response_get_func()

tests/test_content.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b450f19c40>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
________________________ TestContent.test_image_visible ________________________

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450f8b770>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450f8b770>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/kerri72/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f68f50>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f68f50>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450f68230>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e6b40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f691c0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f691c0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450f68620>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e4580>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f69310>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f69310>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450f68290>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e4700>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f693d0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f693d0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450f681d0>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e6f80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f692b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f692b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28c30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450f68770>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e5680>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f69490>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f69490>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f28e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450f68800>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e5f40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f696a0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f696a0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450f68830>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e5c00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f698b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f698b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.ProfilePostContentTester object at 0x79b450f8b530>
client = <django.test.client.Client object at 0x79b450f8b740>
url = '/profile/kerri72/', assert_status_in = (200,)
assert_cbk = 'raise_assert_page_loads_cbk'

    def _testget(
        self,
        client,
        url: Optional[str] = None,
        assert_status_in: Tuple[int] = (200,),
        assert_cbk: Union[
            Callable[[], None], str
        ] = "raise_assert_page_loads_cbk",
    ) -> HttpResponse:
        url = url or self.page_url.url
        try:
>           response = client.get(url)

tests/test_content.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450f8b740>
path = '/profile/kerri72/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv/lib/python3.12/site-packages/django/test/client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450f8b740>
path = '/profile/kerri72/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv/lib/python3.12/site-packages/django/test/client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450f8b740>, method = 'GET'
path = '/profile/kerri72/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/profile/kerri72/', params='', query='', fragment='')
r = {'PATH_INFO': '/profile/kerri72/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv/lib/python3.12/site-packages/django/test/client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.Client object at 0x79b450f8b740>
request = {'PATH_INFO': '/profile/kerri72/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=wbdxfw6fc0ibdczqruc576vj8fsxftml', 'PATH_INFO': '/profile/kerri72/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {}
on_template_render = functools.partial(<function store_rendered_templates at 0x79b451645620>, {})
signal_uid = 'template-render-133815352550272'
exception_uid = 'request-exception-133815352550272'

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
>           response = self.handler(environ)

venv/lib/python3.12/site-packages/django/test/client.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450f8b770>
environ = {'HTTP_COOKIE': 'sessionid=wbdxfw6fc0ibdczqruc576vj8fsxftml', 'PATH_INFO': '/profile/kerri72/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}

    def __call__(self, environ):
        # Set up middleware if needed. We couldn't do this earlier, because
        # settings weren't available.
        if self._middleware_chain is None:
            self.load_middleware()
    
        request_started.disconnect(close_old_connections)
        request_started.send(sender=self.__class__, environ=environ)
        request_started.connect(close_old_connections)
        request = WSGIRequest(environ)
        # sneaky little hack so that we can easily get round
        # CsrfViewMiddleware.  This makes life easier, and is probably
        # required for backwards compatibility with external tests against
        # admin views.
        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks
    
        # Request goes through middleware.
>       response = self.get_response(request)

venv/lib/python3.12/site-packages/django/test/client.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450f8b770>
request = <WSGIRequest: GET '/profile/kerri72/'>

    def get_response(self, request):
        """Return an HttpResponse object for the given HttpRequest."""
        # Setup default url resolver for this thread
        set_urlconf(settings.ROOT_URLCONF)
>       response = self._middleware_chain(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/kerri72/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4508e44c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450f6a030>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450f6a030>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <test_content.TestContent object at 0x79b4512fc140>
user_client = <django.test.client.Client object at 0x79b450f8b740>
post_with_published_location = <Post: Left Hand Week Need Early Practice>

    def test_image_visible(self, user_client, post_with_published_location):
        post = post_with_published_location
        post_adapter = PostModelAdapter(post)
    
        testers: List[PostContentTester] = [
            self.profile_tester,
            self.main_tester,
            self.category_tester,
        ]
        img_n_with_post_img = {}
    
        for i, tester in enumerate(testers):
            img_soup_with_post_img = BeautifulSoup(
>               tester.user_client_testget().content.decode("utf-8"),
                features="html.parser",
                parse_only=SoupStrainer("img"),
            )

tests/test_content.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_content.py:71: in user_client_testget
    return self._testget(
tests/test_content.py:105: in _testget
    getattr(self, assert_cbk)()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_content.ProfilePostContentTester object at 0x79b450f8b530>

    def raise_assert_page_loads_cbk(self):
>       raise AssertionError(
            "Убедитесь, что страница пользователя загружается без ошибок."
        )
E       AssertionError: Убедитесь, что страница пользователя загружается без ошибок.

tests/test_content.py:202: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x79b450e85b20>
user_client = <django.test.client.Client object at 0x79b450e84e30>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
                raise AssertionError(
                    'Убедитесь, что переменная TEMPLATES_DIR в настройках проекта '
                    'является строкой (str) или объектом, соответствующим path-like интерфейсу '
                    '(например, экземпляром pathlib.Path). '
                    f'При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: {e}'
                )
            assert os.path.isfile(
                fpath.resolve()
            ), f"Убедитесь, что файл шаблона `{fpath}` существует."
    
        try:
>           from blogicum.urls import handler500

tests/test_err_pages.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'users.urls'

/usr/lib/python3.12/importlib/__init__.py:90: ModuleNotFoundError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x79b450e85b20>
user_client = <django.test.client.Client object at 0x79b450e84e30>

    @pytest.mark.django_db
    def test_custom_err_handlers(client, user_client):
        err_pages_vs_file_names = {
            404: "404.html",
            403: "403csrf.html",
            500: "500.html",
        }
        for status, fname in err_pages_vs_file_names.items():
            try:
                fpath = settings.TEMPLATES_DIR / "pages" / fname
            except Exception as e:
                raise AssertionError(
                    'Убедитесь, что переменная TEMPLATES_DIR в настройках проекта '
                    'является строкой (str) или объектом, соответствующим path-like интерфейсу '
                    '(например, экземпляром pathlib.Path). '
                    f'При операции конкатенации settings.TEMPLATES_DIR / "pages", возникла ошибка: {e}'
                )
            assert os.path.isfile(
                fpath.resolve()
            ), f"Убедитесь, что файл шаблона `{fpath}` существует."
    
        try:
            from blogicum.urls import handler500
        except Exception:
>           raise AssertionError(
                "Убедитесь, что в головном файле с маршрутами нет ошибок и что в"
                " нём задан обработчик ошибки 500."
            )
E           AssertionError: Убедитесь, что в головном файле с маршрутами нет ошибок и что в нём задан обработчик ошибки 500.

tests/test_err_pages.py:70: AssertionError
___________________________ test_custom_err_handlers ___________________________

client = <django.test.client.Client object at 0x79b450dae690>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
>           from blogicum import urls as blogicum_urls

tests/test_users.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'users.urls'

/usr/lib/python3.12/importlib/__init__.py:90: ModuleNotFoundError

During handling of the above exception, another exception occurred:

client = <django.test.client.Client object at 0x79b450dae690>

    @pytest.mark.django_db
    def test_custom_err_handlers(client):
        try:
            from blogicum import urls as blogicum_urls
        except Exception:
>           raise AssertionError(
                "Убедитесь, в головном файле с маршрутами нет ошибок."
            )
E           AssertionError: Убедитесь, в головном файле с маршрутами нет ошибок.

tests/test_users.py:30: AssertionError
_________________________________ test_profile _________________________________

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450dacf80>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x79b450dacf80>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.12/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>
path = '/profile/this_is_unexisting_user_name/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.12/site-packages/django/urls/resolvers.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1880>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:602: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450daf230>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450daf230>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29e30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x79b450dadf40>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4513a1d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450daf500>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450daf500>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29a30, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x79b450dadd30>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b4507bf840>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450daf710>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450daf710>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f29830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x79b450e85160>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45089fdc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450daf770>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450daf770>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2a030, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x79b450dae090>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450d27240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450daf6b0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450daf6b0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2a230, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x79b450dae1b0>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450de11c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450dafa40>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450dafa40>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2a430, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x79b450dadfa0>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b450de09c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450dafc20>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450dafc20>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2a630, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x79b450dad580>
request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.12/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
exc = ModuleNotFoundError("No module named 'users.urls'")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/profile/this_is_unexisting_user_name/'>
resolver = <URLResolver 'blogicum.urls' (None:None) '^/'>
exc_info = (<class 'ModuleNotFoundError'>, ModuleNotFoundError("No module named 'users.urls'"), <traceback object at 0x79b45108ae00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x79b451ff1820>
instance = <URLResolver 'blogicum.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.12/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'blogicum.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'blogicum.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='blogicum.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x79b450dafef0>, origin='/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py')

>   ???

<frozen importlib._bootstrap>:935: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x79b450dafef0>
module = <module 'blogicum.urls' from '/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x79b450f2a830, file "/home/axine/Dev/django_sprint4/blogicum/blogicum/urls.py", line 1>, {'...ption'>, ...}, '__cached__': '/home/axine/Dev/django_sprint4/blogicum/blogicum/__pycache__/urls.cpython-312.pyc', ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """blogicum URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include, reverse_lazy
    from django.views.generic.edit import CreateView
    from django.contrib.auth.forms import UserCreationForm
    
    handler404 = 'core.views.page_not_found'
    handler500 = 'core.views.internal_server_error'
    
    
    urlpatterns = [
        path('', include('blog.urls')),
        path('pages/', include('pages.urls')),
        path('admin/', admin.site.urls),
        path('auth/', include('django.contrib.auth.urls')),
        path(
            'auth/registration/',
            CreateView.as_view(
                template_name='registration/registration_form.html',
                form_class=UserCreationForm,
                success_url=reverse_lazy('blog:index'),
            ),
            name='registration',
        ),
>       path('profile/', include('users.urls')),
    ]

blogicum/blogicum/urls.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'users.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.12/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/usr/lib/python3.12/importlib/__init__.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???

<frozen importlib._bootstrap>:1360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError

During handling of the above exception, another exception occurred:

user = <User: timothybooth>, another_user = <User: morrishunter>
user_client = <django.test.client.Client object at 0x79b450dacec0>
another_user_client = <django.test.client.Client object at 0x79b4510fec30>
unlogged_client = <django.test.client.Client object at 0x79b450dadd90>

    @pytest.mark.django_db
    def test_profile(
            user, another_user, user_client, another_user_client, unlogged_client
    ):
        user_url = f"/profile/{user.username}/"
        printed_url = "/profile/<username>/"
    
        User = get_user_model()
        status_code_not_404_err_msg = (
            "Убедитесь, что при обращении к странице несуществующего "
            "пользователя возвращается статус 404."
        )
        try:
>           response = user_client.get("/profile/this_is_unexisting_user_name/")

tests/test_users.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.12/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.12/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
venv/lib/python3.12/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
venv/lib/python3.12/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
venv/lib/python3.12/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:615: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.12/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.12/site-packages/django/urls/resolvers.py:595: in urlconf_module
    return import_module(self.urlconf_name)
/usr/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:935: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:995: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
blogicum/blogicum/urls.py:39: in <module>
    path('profile/', include('users.urls')),
venv/lib/python3.12/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/usr/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'users.urls', import_ = <function _gcd_import at 0x79b4544c40e0>

>   ???
E   ModuleNotFoundError: No module named 'users.urls'

<frozen importlib._bootstrap>:1324: ModuleNotFoundError
_________________________ test_email_backend_settings __________________________

    def test_email_backend_settings():
        assert hasattr(
            settings, "EMAIL_BACKEND"
        ), "Убедитесь, что в проекте задана настройка `EMAIL_BACKEND`."
        assert EmailBackend.__module__ in settings.EMAIL_BACKEND, (
            "Убедитесь, что файловый бэкенд для отправки e-mail подключен с"
            " помощью настройки `EMAIL_BACKEND`."
        )
        excpect_email_file = settings.BASE_DIR / "sent_emails"
>       assert getattr(settings, "EMAIL_FILE_PATH", "") == excpect_email_file, (
            "Убедитесь, что в настройке `EMAIL_FILE_PATH` указан путь `BASE_DIR /"
            " 'sent_emails'`."
        )
E       AssertionError: Убедитесь, что в настройке `EMAIL_FILE_PATH` указан путь `BASE_DIR / 'sent_emails'`.
E       assert '' == PosixPath('/home/axine/Dev/django_sprint4/blogicum/sent_emails')
E        +  where '' = getattr(<LazySettings "None">, 'EMAIL_FILE_PATH', '')

tests/test_emails.py:34: AssertionError
____________________________ test_csrf_failure_view ____________________________

parser = <django.template.base.Parser object at 0x79b450734fb0>
name = 'django_bootstrap5'

    def find_library(parser, name):
        try:
>           return parser.libraries[name]
E           KeyError: 'django_bootstrap5'

venv/lib/python3.12/site-packages/django/template/defaulttags.py:1037: KeyError

During handling of the above exception, another exception occurred:

    def test_csrf_failure_view():
        csrf_failure_view_setting = getattr(settings, "CSRF_FAILURE_VIEW", "")
        module_name, function_name = csrf_failure_view_setting.rsplit(".", 1)
        csrf_failure_view = None
        try:
            module = import_module(module_name)
            csrf_failure_view = getattr(module, function_name, None)
        except Exception:
            pass
        assert csrf_failure_view, (
            "Убедитесь, что в `settings.py` задана настройка `CSRF_FAILURE_VIEW` и"
            " что она указывает на существующую view-функцию."
        )
    
        request = HttpRequest()
        request.method = "POST"
        request.POST = {}
    
        try:
>           response = csrf_failure_view(request)

tests/test_err_pages.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <HttpRequest>, reason = ''

    def csrf_failure(request, reason=''):
>       return render(request, 'pages/403csrf.html', status=403)

blogicum/core/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <HttpRequest>, template_name = 'pages/403csrf.html', context = None
content_type = None, status = 403, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv/lib/python3.12/site-packages/django/shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

template_name = 'pages/403csrf.html', context = None, request = <HttpRequest>
using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv/lib/python3.12/site-packages/django/template/loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.backends.django.Template object at 0x79b450afdf10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]
request = <HttpRequest>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv/lib/python3.12/site-packages/django/template/backends/django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x79b4507344d0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv/lib/python3.12/site-packages/django/template/base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x79b4507344d0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv/lib/python3.12/site-packages/django/test/utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv/lib/python3.12/site-packages/django/template/base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv/lib/python3.12/site-packages/django/template/base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def render(self, context):
>       compiled_parent = self.get_parent(context)

venv/lib/python3.12/site-packages/django/template/loader_tags.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def get_parent(self, context):
        parent = self.parent_name.resolve(context)
        if not parent:
            error_msg = "Invalid template name in 'extends' tag: %r." % parent
            if self.parent_name.filters or\
                    isinstance(self.parent_name.var, Variable):
                error_msg += " Got this from the '%s' variable." %\
                    self.parent_name.token
            raise TemplateSyntaxError(error_msg)
        if isinstance(parent, Template):
            # parent is a django.template.Template
            return parent
        if isinstance(getattr(parent, 'template', None), Template):
            # parent is a django.template.backends.django.Template
            return parent.template
>       return self.find_template(parent, context)

venv/lib/python3.12/site-packages/django/template/loader_tags.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <ExtendsNode: extends "base.html">, template_name = 'base.html'
context = [{'True': True, 'False': False, 'None': None}, {}, {}]

    def find_template(self, template_name, context):
        """
        This is a wrapper around engine.find_template(). A history is kept in
        the render_context attribute between successive extends calls and
        passed as the skip argument. This enables extends to work recursively
        without extending the same template twice.
        """
        history = context.render_context.setdefault(
            self.context_key, [self.origin],
        )
>       template, origin = context.template.engine.find_template(
            template_name, skip=history,
        )

venv/lib/python3.12/site-packages/django/template/loader_tags.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.engine.Engine object at 0x79b450ac5010>
name = 'base.html', dirs = None
skip = [<django.template.base.Origin object at 0x79b4507341d0>]

    def find_template(self, name, dirs=None, skip=None):
        tried = []
        for loader in self.template_loaders:
            try:
>               template = loader.get_template(name, skip=skip)

venv/lib/python3.12/site-packages/django/template/engine.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loaders.cached.Loader object at 0x79b450ac53d0>
template_name = 'base.html'
skip = [<django.template.base.Origin object at 0x79b4507341d0>]

    def get_template(self, template_name, skip=None):
        """
        Perform the caching that gives this loader its name. Often many of the
        templates attempted will be missing, so memory use is of concern here.
        To keep it in check, caching behavior is a little complicated when a
        template is not found. See ticket #26306 for more details.
    
        With template debugging disabled, cache the TemplateDoesNotExist class
        for every missing template and raise a new instance of it after
        fetching it from the cache.
    
        With template debugging enabled, a unique TemplateDoesNotExist object
        is cached for each missing template to preserve debug data. When
        raising an exception, Python sets __traceback__, __context__, and
        __cause__ attributes on it. Those attributes can contain references to
        all sorts of objects up the call chain and caching them creates a
        memory leak. Thus, unraised copies of the exceptions are cached and
        copies of those copies are raised after they're fetched from the cache.
        """
        key = self.cache_key(template_name, skip)
        cached = self.get_template_cache.get(key)
        if cached:
            if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):
                raise cached(template_name)
            elif isinstance(cached, TemplateDoesNotExist):
                raise copy_exception(cached)
            return cached
    
        try:
>           template = super().get_template(template_name, skip)

venv/lib/python3.12/site-packages/django/template/loaders/cached.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.loaders.cached.Loader object at 0x79b450ac53d0>
template_name = 'base.html'
skip = [<django.template.base.Origin object at 0x79b4507341d0>]

    def get_template(self, template_name, skip=None):
        """
        Call self.get_template_sources() and return a Template object for
        the first template matching template_name. If skip is provided, ignore
        template origins in skip. This is used to avoid recursion during
        template extending.
        """
        tried = []
    
        for origin in self.get_template_sources(template_name):
            if skip is not None and origin in skip:
                tried.append((origin, 'Skipped to avoid recursion'))
                continue
    
            try:
                contents = self.get_contents(origin)
            except TemplateDoesNotExist:
                tried.append((origin, 'Source does not exist'))
                continue
            else:
>               return Template(
                    contents, origin, origin.template_name, self.engine,
                )

venv/lib/python3.12/site-packages/django/template/loaders/base.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x79b450734fe0>
template_string = '{% load static %}\n{% load django_bootstrap5 %}\n<!DOCTYPE html>\n<html lang="ru">\n  <head>\n    <meta charset="utf-...lock content %}{% endblock %}\n      </div>\n    </main>\n    {% include "includes/footer.html" %}\n  </body>\n</html>'
origin = <django.template.base.Origin object at 0x79b450734f20>
name = 'base.html'
engine = <django.template.engine.Engine object at 0x79b450ac5010>

    def __init__(self, template_string, origin=None, name=None, engine=None):
        # If Template is instantiated directly rather than from an Engine and
        # exactly one Django template engine is configured, use that engine.
        # This is required to preserve backwards-compatibility for direct use
        # e.g. Template('...').render(Context({...}))
        if engine is None:
            from .engine import Engine
            engine = Engine.get_default()
        if origin is None:
            origin = Origin(UNKNOWN_SOURCE)
        self.name = name
        self.origin = origin
        self.engine = engine
        self.source = str(template_string)  # May be lazy.
>       self.nodelist = self.compile_nodelist()

venv/lib/python3.12/site-packages/django/template/base.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Template object at 0x79b450734fe0>

    def compile_nodelist(self):
        """
        Parse and compile the template source into a nodelist. If debug
        is True and an exception occurs during parsing, the exception is
        annotated with contextual line information where it occurred in the
        template source.
        """
        if self.engine.debug:
            lexer = DebugLexer(self.source)
        else:
            lexer = Lexer(self.source)
    
        tokens = lexer.tokenize()
        parser = Parser(
            tokens, self.engine.template_libraries, self.engine.template_builtins,
            self.origin,
        )
    
        try:
>           return parser.parse()

venv/lib/python3.12/site-packages/django/template/base.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Parser object at 0x79b450734fb0>, parse_until = []

    def parse(self, parse_until=None):
        """
        Iterate through the parser tokens and compiles each one into a node.
    
        If parse_until is provided, parsing will stop once one of the
        specified tokens has been reached. This is formatted as a list of
        tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
        reached, raise an exception with the unclosed block tag details.
        """
        if parse_until is None:
            parse_until = []
        nodelist = NodeList()
        while self.tokens:
            token = self.next_token()
            # Use the raw values here for TokenType.* for a tiny performance boost.
            if token.token_type.value == 0:  # TokenType.TEXT
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
            elif token.token_type.value == 1:  # TokenType.VAR
                if not token.contents:
                    raise self.error(token, 'Empty variable tag on line %d' % token.lineno)
                try:
                    filter_expression = self.compile_filter(token.contents)
                except TemplateSyntaxError as e:
                    raise self.error(token, e)
                var_node = VariableNode(filter_expression)
                self.extend_nodelist(nodelist, var_node, token)
            elif token.token_type.value == 2:  # TokenType.BLOCK
                try:
                    command = token.contents.split()[0]
                except IndexError:
                    raise self.error(token, 'Empty block tag on line %d' % token.lineno)
                if command in parse_until:
                    # A matching token has been reached. Return control to
                    # the caller. Put the token back on the token list so the
                    # caller knows where it terminated.
                    self.prepend_token(token)
                    return nodelist
                # Add the token to the command stack. This is used for error
                # messages if further parsing fails due to an unclosed block
                # tag.
                self.command_stack.append((command, token))
                # Get the tag callback function from the ones registered with
                # the parser.
                try:
                    compile_func = self.tags[command]
                except KeyError:
                    self.invalid_block_tag(token, command, parse_until)
                # Compile the callback into a node object and add it to
                # the node list.
                try:
                    compiled_result = compile_func(self, token)
                except Exception as e:
>                   raise self.error(token, e)

venv/lib/python3.12/site-packages/django/template/base.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.template.base.Parser object at 0x79b450734fb0>, parse_until = []

    def parse(self, parse_until=None):
        """
        Iterate through the parser tokens and compiles each one into a node.
    
        If parse_until is provided, parsing will stop once one of the
        specified tokens has been reached. This is formatted as a list of
        tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
        reached, raise an exception with the unclosed block tag details.
        """
        if parse_until is None:
            parse_until = []
        nodelist = NodeList()
        while self.tokens:
            token = self.next_token()
            # Use the raw values here for TokenType.* for a tiny performance boost.
            if token.token_type.value == 0:  # TokenType.TEXT
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
            elif token.token_type.value == 1:  # TokenType.VAR
                if not token.contents:
                    raise self.error(token, 'Empty variable tag on line %d' % token.lineno)
                try:
                    filter_expression = self.compile_filter(token.contents)
                except TemplateSyntaxError as e:
                    raise self.error(token, e)
                var_node = VariableNode(filter_expression)
                self.extend_nodelist(nodelist, var_node, token)
            elif token.token_type.value == 2:  # TokenType.BLOCK
                try:
                    command = token.contents.split()[0]
                except IndexError:
                    raise self.error(token, 'Empty block tag on line %d' % token.lineno)
                if command in parse_until:
                    # A matching token has been reached. Return control to
                    # the caller. Put the token back on the token list so the
                    # caller knows where it terminated.
                    self.prepend_token(token)
                    return nodelist
                # Add the token to the command stack. This is used for error
                # messages if further parsing fails due to an unclosed block
                # tag.
                self.command_stack.append((command, token))
                # Get the tag callback function from the ones registered with
                # the parser.
                try:
                    compile_func = self.tags[command]
                except KeyError:
                    self.invalid_block_tag(token, command, parse_until)
                # Compile the callback into a node object and add it to
                # the node list.
                try:
>                   compiled_result = compile_func(self, token)

venv/lib/python3.12/site-packages/django/template/base.py:476: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

parser = <django.template.base.Parser object at 0x79b450734fb0>
token = <django.template.base.Token object at 0x79b450735070>

    @register.tag
    def load(parser, token):
        """
        Load a custom template tag library into the parser.
    
        For example, to load the template tags in
        ``django/templatetags/news/photos.py``::
    
            {% load news.photos %}
    
        Can also be used to load an individual tag/filter from
        a library::
    
            {% load byline from news %}
        """
        # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments
        bits = token.contents.split()
        if len(bits) >= 4 and bits[-2] == "from":
            # from syntax is used; load individual tags from the library
            name = bits[-1]
            lib = find_library(parser, name)
            subset = load_from_library(lib, name, bits[1:-2])
            parser.add_library(subset)
        else:
            # one or more libraries are specified; load and add them to the parser
            for name in bits[1:]:
>               lib = find_library(parser, name)

venv/lib/python3.12/site-packages/django/template/defaulttags.py:1094: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

parser = <django.template.base.Parser object at 0x79b450734fb0>
name = 'django_bootstrap5'

    def find_library(parser, name):
        try:
            return parser.libraries[name]
        except KeyError:
>           raise TemplateSyntaxError(
                "'%s' is not a registered tag library. Must be one of:\n%s" % (
                    name, "\n".join(sorted(parser.libraries)),
                ),
            )
E           django.template.exceptions.TemplateSyntaxError: 'django_bootstrap5' is not a registered tag library. Must be one of:
E           admin_list
E           admin_modify
E           admin_urls
E           cache
E           i18n
E           l10n
E           log
E           static
E           tz

venv/lib/python3.12/site-packages/django/template/defaulttags.py:1039: TemplateSyntaxError

During handling of the above exception, another exception occurred:

    def test_csrf_failure_view():
        csrf_failure_view_setting = getattr(settings, "CSRF_FAILURE_VIEW", "")
        module_name, function_name = csrf_failure_view_setting.rsplit(".", 1)
        csrf_failure_view = None
        try:
            module = import_module(module_name)
            csrf_failure_view = getattr(module, function_name, None)
        except Exception:
            pass
        assert csrf_failure_view, (
            "Убедитесь, что в `settings.py` задана настройка `CSRF_FAILURE_VIEW` и"
            " что она указывает на существующую view-функцию."
        )
    
        request = HttpRequest()
        request.method = "POST"
        request.POST = {}
    
        try:
            response = csrf_failure_view(request)
        except Exception:
>           raise AssertionError(
                f"Убедитесь, что view-функция `{csrf_failure_view_setting}`"
                " работает без ошибок."
            )
E           AssertionError: Убедитесь, что view-функция `core.views.csrf_failure` работает без ошибок.

tests/test_err_pages.py:34: AssertionError
______________ TestPostModelAttrs.test_model_attrs[`image` field] ______________

self = <adapters.post.PostModelAdapter object at 0x79b450afd8e0>, name = 'image'

    def __getattr__(self, name: str) -> Any:
        if name.startswith("_") or name in self._access_by_name_fields:
            return getattr(self._item_or_cls, name)
    
        item_fields = [
            (f.name, type(f), getattr(self.ItemModel, f.name).field)
            for f in self.ItemModel._meta.concrete_fields
            if issubclass(type(f), Field)
            and (f.name not in self._access_by_name_fields)
        ]
    
        item_field_names = {
            get_field_key(_type, field): name
            for name, _type, field in item_fields
        }
    
        assert len(item_field_names) == len(item_fields), (
            f"Убедитесь, что в модели {self.ItemModel.__name__} нет полей,"
            " которые не описаны в задании. Проверьте, что для всех полей"
            " модели правильно заданы типы."
        )
    
        adapter_field_key = get_field_key(
            type(getattr(self.AdapterFields, name)),
            getattr(self.AdapterFields, name),
        )
        try:
>           item_field_name = item_field_names[adapter_field_key]
E           KeyError: ('ImageField', None)

tests/adapters/student_adapter.py:56: KeyError

During handling of the above exception, another exception occurred:

self = <test_post.TestPostModelAttrs object at 0x79b4513712e0>, field = 'image'
type = <class 'django.db.models.fields.files.ImageField'>, params = {}
field_error = 'В модели `Post` укажите атрибут `image`.', type_error = None
param_error = None, value_error = None

    def test_model_attrs(
            self, field: str, type: type, params: dict,
            field_error: Optional[str], type_error: Optional[str],
            param_error: Optional[str], value_error: Optional[str]):
        model_name = self.model.__name__
        field_error = field_error or (
            f"В модели `{model_name}` укажите атрибут `{field}`.")
>       assert hasattr(self.model, field), field_error

tests/conftest.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <adapters.post.PostModelAdapter object at 0x79b450afd8e0>, name = 'image'

    def __getattr__(self, name: str) -> Any:
        if name.startswith("_") or name in self._access_by_name_fields:
            return getattr(self._item_or_cls, name)
    
        item_fields = [
            (f.name, type(f), getattr(self.ItemModel, f.name).field)
            for f in self.ItemModel._meta.concrete_fields
            if issubclass(type(f), Field)
            and (f.name not in self._access_by_name_fields)
        ]
    
        item_field_names = {
            get_field_key(_type, field): name
            for name, _type, field in item_fields
        }
    
        assert len(item_field_names) == len(item_fields), (
            f"Убедитесь, что в модели {self.ItemModel.__name__} нет полей,"
            " которые не описаны в задании. Проверьте, что для всех полей"
            " модели правильно заданы типы."
        )
    
        adapter_field_key = get_field_key(
            type(getattr(self.AdapterFields, name)),
            getattr(self.AdapterFields, name),
        )
        try:
            item_field_name = item_field_names[adapter_field_key]
        except KeyError:
>           raise AssertionError(
                f"В модели `{self.ItemModel.__name__}` создайте поле типа"
                f" `{adapter_field_key[0]}`, которое"
                f" {self.AdapterFields.field_description[name]}."
            )
E           AssertionError: В модели `Post` создайте поле типа `ImageField`, которое служит для хранения изображения публикации.

tests/adapters/student_adapter.py:58: AssertionError
___________________________ test_static_pages_as_cbv ___________________________

    def test_static_pages_as_cbv():
        try:
            from pages import urls
        except Exception as e:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` нет ошибок. При его"
                f" импорте возникла ошибка:\n{type(e).__name__}: {e}"
            )
        try:
            from pages.urls import urlpatterns
        except Exception:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` задан список urlpatterns."
            )
        try:
            from pages.urls import app_name
        except Exception:
            raise AssertionError(
                "Убедитесь, что в файле `pages/urls.py` определена глобальная"
                " переменная `app_name`, задающая пространство имён url для"
                " приложения `pages`."
            )
        for path in urlpatterns:
            if not hasattr(path.callback, "view_class"):
>               raise AssertionError(
                    "Убедитесь, что в файле `pages/urls.py` маршруты статических"
                    " страниц подключены с помощью CBV."
                )
E               AssertionError: Убедитесь, что в файле `pages/urls.py` маршруты статических страниц подключены с помощью CBV.

tests/test_static_pages.py:25: AssertionError
=========================== short test summary info ============================
ERROR tests/test_comment.py::test_comment_created_at - AssertionError: Убедит...
ERROR tests/test_comment.py::test_comment - ModuleNotFoundError: No module na...
ERROR tests/test_comment.py::test_404_on_comment_deleted_post - ModuleNotFoun...
ERROR tests/test_post.py::test_post - AssertionError: Убедитесь, что в файле ...
ERROR tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`post` field]
ERROR tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`author` field]
ERROR tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`text` field]
ERROR tests/test_comment.py::TestCommentModelAttrs::test_model_attrs[`created_at` field]
ERROR tests/test_static_pages.py::test_static_pages_as_cbv - AttributeError: ...
============= 14 failed, 3 passed, 233 warnings, 9 errors in 2.02s =============
